/* eslint-disable no-console */
const fs = require("fs");
const { execSync } = require("child_process");

function sh(cmd) {
  return execSync(cmd, { stdio: ["ignore", "pipe", "pipe"] }).toString("utf8").trim();
}

function nowIso() {
  // Use UTC for auditability; readers can interpret consistently.
  return new Date().toISOString();
}

function ensureEnv(name) {
  const v = process.env[name];
  if (!v || !v.trim()) throw new Error(`Missing required env var: ${name}`);
  return v.trim();
}

function readFileSafe(path) {
  try {
    return fs.readFileSync(path, "utf8");
  } catch {
    return "";
  }
}

function ensureReadmeHasChangelog(readme) {
  const marker = "## Changelog";
  if (readme.includes(marker)) return readme;
  const append = `\n\n${marker}\n\n> Automated entries generated by CI after code changes.\n`;
  return readme.trimEnd() + append + "\n";
}

function insertAfterChangelogHeader(readme, entryMarkdown) {
  const marker = "## Changelog";
  const idx = readme.indexOf(marker);
  if (idx === -1) {
    // Fallback: append to end
    return readme.trimEnd() + "\n\n" + entryMarkdown + "\n";
  }

  // Insert immediately after the header block (after "## Changelog" line)
  const afterHeaderIdx = readme.indexOf("\n", idx);
  if (afterHeaderIdx === -1) {
    return readme + "\n\n" + entryMarkdown + "\n";
  }

  const before = readme.slice(0, afterHeaderIdx + 1);
  const after = readme.slice(afterHeaderIdx + 1);

  // Keep newest entries at top
  return before + "\n" + entryMarkdown + "\n" + after.trimStart();
}

function getGitContext() {
  const commitSha = process.env.GITHUB_SHA || sh("git rev-parse HEAD");
  const shortSha = commitSha.slice(0, 7);
  const repo = process.env.GITHUB_REPOSITORY || "";
  const ref = process.env.GITHUB_REF_NAME || sh("git rev-parse --abbrev-ref HEAD");

  // Changed files in latest commit
  const changedFiles = sh(`git show --name-only --pretty=format: ${commitSha}`)
    .split("\n")
    .map(s => s.trim())
    .filter(Boolean);

  // Commit subject/body
  const subject = sh(`git log -1 --pretty=%s ${commitSha}`);
  const body = sh(`git log -1 --pretty=%b ${commitSha}`);

  // Diffstat (compact)
  const diffStat = sh(`git show --stat --oneline --pretty=format: ${commitSha}`);

  // Patch (truncate to keep prompt bounded)
  let patch = "";
  try {
    patch = sh(`git show --pretty=format: ${commitSha}`);
  } catch {
    patch = "";
  }
  const MAX_PATCH_CHARS = 12000;
  if (patch.length > MAX_PATCH_CHARS) patch = patch.slice(0, MAX_PATCH_CHARS) + "\n...[truncated]";

  return {
    repo,
    ref,
    commitSha,
    shortSha,
    subject,
    body,
    changedFiles,
    diffStat,
    patch
  };
}

async function callOpenAI({ apiKey, model, messages }) {
  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      model,
      messages,
      temperature: 0.4
    })
  });

  if (!res.ok) {
    const txt = await res.text();
    throw new Error(`OpenAI API error ${res.status}: ${txt}`);
  }

  const data = await res.json();
  const content = data?.choices?.[0]?.message?.content;
  if (!content) throw new Error("OpenAI API: missing response content");
  return content.trim();
}

(async function main() {
  const apiKey = ensureEnv("OPENAI_API_KEY");
  const model = (process.env.OPENAI_MODEL && process.env.OPENAI_MODEL.trim()) || "gpt-4.1-mini";

  const timestamp = nowIso();
  const git = getGitContext();

  const readmePath = "README.md";
  let readme = readFileSafe(readmePath);
  readme = ensureReadmeHasChangelog(readme);

  const changedFilesBullets = git.changedFiles.length
    ? git.changedFiles.map(f => `- \`${f}\``).join("\n")
    : "- (no file list available)";

  const system = [
    "You are a senior engineering leader writing release notes for a GitHub repository.",
    "Write in clear, high-quality business/technical English.",
    "Be accurate: only describe changes supported by the provided commit metadata and diff.",
    "Prefer concise clarity over hype.",
    "Output MUST be a single Markdown block suitable for insertion into README.md under '## Changelog'.",
    "Do NOT include code fences unless absolutely necessary.",
    "Structure the entry as:",
    "### YYYY-MM-DD HH:MM UTC — <short title>",
    "- Summary: <1-3 bullets>",
    "- Impact: <who/what is affected>",
    "- Notes: <any risks, migrations, follow-ups>",
    "- Links: <commit link placeholder using repo + sha if repo available>"
  ].join("\n");

  const user = [
    `Timestamp (UTC ISO): ${timestamp}`,
    `Repo: ${git.repo || "(unknown)"}`,
    `Branch/Ref: ${git.ref}`,
    `Commit: ${git.commitSha}`,
    `Commit subject: ${git.subject}`,
    `Commit body: ${git.body || "(none)"}`,
    "",
    "Changed files:",
    changedFilesBullets,
    "",
    "Diff stat:",
    git.diffStat,
    "",
    "Patch (may be truncated):",
    git.patch
  ].join("\n");

  const aiEntryRaw = await callOpenAI({
    apiKey,
    model,
    messages: [
      { role: "system", content: system },
      { role: "user", content: user }
    ]
  });

  // Normalize title line to the required format if model deviates.
  // Minimal tampering: accept AI output as-is if it begins with ###.
  let aiEntry = aiEntryRaw;
  if (!aiEntry.startsWith("### ")) {
    // Wrap into a safe default entry; still includes AI content verbatim below.
    const d = new Date(timestamp);
    const ymd = d.toISOString().slice(0, 10);
    const hm = d.toISOString().slice(11, 16);
    aiEntry =
      `### ${ymd} ${hm} UTC — Update\n` +
      `- Summary: (generated)\n` +
      `- Impact: (generated)\n` +
      `- Notes: (generated)\n` +
      `- Links: ${git.repo ? `https://github.com/${git.repo}/commit/${git.commitSha}` : git.commitSha}\n\n` +
      aiEntryRaw;
  }

  // Ensure links line has a real commit URL when repo is known.
  if (git.repo) {
    const commitUrl = `https://github.com/${git.repo}/commit/${git.commitSha}`;
    if (!aiEntry.includes("http")) {
      aiEntry += `\n- Links: ${commitUrl}\n`;
    } else if (aiEntry.includes("- Links:") && !aiEntry.includes(commitUrl)) {
      // If there are other links, add commit link explicitly
      aiEntry += `\n- Links: ${commitUrl}\n`;
    }
  }

  const updated = insertAfterChangelogHeader(readme, aiEntry);
  fs.writeFileSync(readmePath, updated, "utf8");

  console.log("README.md updated with AI changelog entry.");
})();
